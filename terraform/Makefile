# ============================================================
# Makefile - Terraform Infrastructure Management
# ============================================================

.PHONY: help init plan apply destroy validate fmt clean backend check-backend output ssh-afor ssh-cvgfr ssh-prefet ssh-orderer

# Variables
TERRAFORM := terraform
AWS := aws
BACKEND_SCRIPT := ../scripts/terraform/setup-backend.sh
PLAN_FILE := tfplan

# Couleurs
GREEN := \033[0;32m
YELLOW := \033[1;33m
RED := \033[0;31m
NC := \033[0m # No Color

help: ## Afficher cette aide
	@echo "========================================="
	@echo "üöÄ Terraform - Hyperledger Fabric AWS"
	@echo "========================================="
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2}'
	@echo ""

check-backend: ## V√©rifier que le backend S3/DynamoDB existe
	@echo "$(YELLOW)üîç V√©rification du backend Terraform...$(NC)"
	@$(AWS) s3 ls s3://afor-blockchain-terraform-state > /dev/null 2>&1 || \
		(echo "$(RED)‚ùå Backend S3 non trouv√©. Ex√©cuter 'make backend' d'abord.$(NC)" && exit 1)
	@$(AWS) dynamodb describe-table --table-name afor-blockchain-terraform-locks > /dev/null 2>&1 || \
		(echo "$(RED)‚ùå Table DynamoDB non trouv√©e. Ex√©cuter 'make backend' d'abord.$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Backend configur√© correctement$(NC)"

backend: ## Cr√©er le backend S3 + DynamoDB pour Terraform
	@echo "$(YELLOW)üì¶ Configuration du backend Terraform...$(NC)"
	@chmod +x $(BACKEND_SCRIPT)
	@$(BACKEND_SCRIPT)

init: check-backend ## Initialiser Terraform (t√©l√©charger les providers)
	@echo "$(YELLOW)üîß Initialisation de Terraform...$(NC)"
	@$(TERRAFORM) init -upgrade
	@echo "$(GREEN)‚úÖ Terraform initialis√©$(NC)"

validate: ## Valider la syntaxe Terraform
	@echo "$(YELLOW)‚úîÔ∏è  Validation de la configuration...$(NC)"
	@$(TERRAFORM) validate
	@echo "$(GREEN)‚úÖ Configuration valide$(NC)"

fmt: ## Formater le code Terraform
	@echo "$(YELLOW)üìù Formatage du code...$(NC)"
	@$(TERRAFORM) fmt -recursive
	@echo "$(GREEN)‚úÖ Code format√©$(NC)"

plan: validate ## Cr√©er un plan de d√©ploiement
	@echo "$(YELLOW)üìä Cr√©ation du plan de d√©ploiement...$(NC)"
	@$(TERRAFORM) plan -out=$(PLAN_FILE)
	@echo ""
	@echo "$(GREEN)‚úÖ Plan cr√©√©: $(PLAN_FILE)$(NC)"
	@echo "Ex√©cuter 'make apply' pour d√©ployer"

plan-destroy: validate ## Cr√©er un plan de destruction
	@echo "$(YELLOW)üìä Cr√©ation du plan de destruction...$(NC)"
	@$(TERRAFORM) plan -destroy -out=$(PLAN_FILE)
	@echo ""
	@echo "$(RED)‚ö†Ô∏è  Plan de destruction cr√©√©: $(PLAN_FILE)$(NC)"
	@echo "Ex√©cuter 'make apply' pour d√©truire (‚ö†Ô∏è DANGER)"

apply: ## Appliquer le plan de d√©ploiement
	@if [ ! -f $(PLAN_FILE) ]; then \
		echo "$(RED)‚ùå Fichier de plan non trouv√©. Ex√©cuter 'make plan' d'abord.$(NC)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)üöÄ Application du plan...$(NC)"
	@$(TERRAFORM) apply $(PLAN_FILE)
	@rm -f $(PLAN_FILE)
	@echo ""
	@echo "$(GREEN)‚úÖ D√©ploiement termin√© !$(NC)"
	@echo ""
	@make output

apply-auto: plan ## Appliquer automatiquement (sans confirmation)
	@echo "$(RED)‚ö†Ô∏è  Application automatique en cours...$(NC)"
	@$(TERRAFORM) apply -auto-approve
	@echo "$(GREEN)‚úÖ D√©ploiement termin√© !$(NC)"

destroy: ## D√©truire toute l'infrastructure (‚ö†Ô∏è DANGER)
	@echo "$(RED)‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è  DESTRUCTION DE L'INFRASTRUCTURE ‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è$(NC)"
	@echo ""
	@read -p "Taper 'yes' pour confirmer la destruction: " confirm; \
	if [ "$$confirm" = "yes" ]; then \
		$(TERRAFORM) destroy; \
	else \
		echo "$(YELLOW)‚ùå Destruction annul√©e$(NC)"; \
	fi

destroy-auto: ## D√©truire automatiquement (‚ö†Ô∏è‚ö†Ô∏è EXTR√äMEMENT DANGEREUX)
	@echo "$(RED)‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è  DESTRUCTION AUTOMATIQUE ‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è$(NC)"
	@$(TERRAFORM) destroy -auto-approve

output: ## Afficher les outputs Terraform
	@echo "$(YELLOW)üìã Outputs Terraform:$(NC)"
	@echo ""
	@$(TERRAFORM) output
	@echo ""

output-json: ## Sauvegarder les outputs en JSON
	@echo "$(YELLOW)üíæ Sauvegarde des outputs...$(NC)"
	@$(TERRAFORM) output -json > outputs.json
	@echo "$(GREEN)‚úÖ Outputs sauvegard√©s dans outputs.json$(NC)"

state-list: ## Lister les ressources dans l'√©tat Terraform
	@$(TERRAFORM) state list

state-show: ## Afficher les d√©tails d'une ressource (usage: make state-show RESOURCE=module.vpc)
	@$(TERRAFORM) state show $(RESOURCE)

refresh: ## Rafra√Æchir l'√©tat Terraform
	@echo "$(YELLOW)üîÑ Rafra√Æchissement de l'√©tat...$(NC)"
	@$(TERRAFORM) refresh
	@echo "$(GREEN)‚úÖ √âtat rafra√Æchi$(NC)"

graph: ## G√©n√©rer un graphe de d√©pendances
	@echo "$(YELLOW)üìä G√©n√©ration du graphe...$(NC)"
	@$(TERRAFORM) graph | dot -Tpng > graph.png
	@echo "$(GREEN)‚úÖ Graphe sauvegard√©: graph.png$(NC)"

clean: ## Nettoyer les fichiers temporaires
	@echo "$(YELLOW)üßπ Nettoyage...$(NC)"
	@rm -rf .terraform .terraform.lock.hcl $(PLAN_FILE) outputs.json graph.png
	@echo "$(GREEN)‚úÖ Nettoyage termin√©$(NC)"

# ============================================================
# Commandes SSH
# ============================================================

ssh-afor: ## SSH vers le peer AFOR
	@INSTANCE_IP=$$($(TERRAFORM) output -json | jq -r '.peer_afor_private_ip.value'); \
	echo "$(YELLOW)üîê Connexion SSH √† AFOR ($$INSTANCE_IP)...$(NC)"; \
	ssh -i ~/.ssh/afor-blockchain-key.pem ubuntu@$$INSTANCE_IP

ssh-cvgfr: ## SSH vers le peer CVGFR
	@INSTANCE_IP=$$($(TERRAFORM) output -json | jq -r '.peer_cvgfr_private_ip.value'); \
	echo "$(YELLOW)üîê Connexion SSH √† CVGFR ($$INSTANCE_IP)...$(NC)"; \
	ssh -i ~/.ssh/afor-blockchain-key.pem ubuntu@$$INSTANCE_IP

ssh-prefet: ## SSH vers le peer PREFET
	@INSTANCE_IP=$$($(TERRAFORM) output -json | jq -r '.peer_prefet_private_ip.value'); \
	echo "$(YELLOW)üîê Connexion SSH √† PREFET ($$INSTANCE_IP)...$(NC)"; \
	ssh -i ~/.ssh/afor-blockchain-key.pem ubuntu@$$INSTANCE_IP

ssh-orderer: ## SSH vers l'orderer
	@INSTANCE_IP=$$($(TERRAFORM) output -json | jq -r '.orderer_private_ip.value'); \
	echo "$(YELLOW)üîê Connexion SSH √† Orderer ($$INSTANCE_IP)...$(NC)"; \
	ssh -i ~/.ssh/afor-blockchain-key.pem ubuntu@$$INSTANCE_IP

# ============================================================
# Commandes AWS
# ============================================================

instances: ## Lister les instances EC2
	@echo "$(YELLOW)üìã Instances EC2:$(NC)"
	@$(AWS) ec2 describe-instances \
		--filters "Name=tag:Project,Values=afor-blockchain" \
		--query 'Reservations[*].Instances[*].[InstanceId,State.Name,PrivateIpAddress,Tags[?Key==`Name`].Value|[0]]' \
		--output table

logs-peer: ## Afficher les logs CloudWatch des peers
	@echo "$(YELLOW)üìã Logs Fabric Peers:$(NC)"
	@$(AWS) logs tail /aws/ec2/fabric-peer --follow

logs-orderer: ## Afficher les logs CloudWatch de l'orderer
	@echo "$(YELLOW)üìã Logs Fabric Orderer:$(NC)"
	@$(AWS) logs tail /aws/ec2/fabric-orderer --follow

alb-status: ## V√©rifier le status du Load Balancer
	@echo "$(YELLOW)üîç Status ALB:$(NC)"
	@$(AWS) elbv2 describe-load-balancers \
		--names afor-blockchain-api-lb \
		--query 'LoadBalancers[*].[LoadBalancerName,DNSName,State.Code]' \
		--output table

alb-targets: ## V√©rifier les targets du Load Balancer
	@TG_ARN=$$($(AWS) elbv2 describe-target-groups --names afor-blockchain-api-tg --query 'TargetGroups[0].TargetGroupArn' --output text); \
	echo "$(YELLOW)üéØ Targets ALB:$(NC)"; \
	$(AWS) elbv2 describe-target-health --target-group-arn $$TG_ARN --output table

costs: ## Estimer les co√ªts mensuels
	@echo "$(YELLOW)üí∞ Estimation des co√ªts mensuels (us-east-1):$(NC)"
	@echo ""
	@echo "  Compute:"
	@echo "    - 3x EC2 t3.large (24/7)       ~$150"
	@echo "    - 1x EC2 t3.xlarge (24/7)      ~$100"
	@echo ""
	@echo "  R√©seau:"
	@echo "    - 3x NAT Gateway                ~$100"
	@echo "    - Application Load Balancer     ~$20"
	@echo ""
	@echo "  Stockage:"
	@echo "    - EBS Storage (630 GB)          ~$65"
	@echo "    - S3 Backups (~100 GB)          ~$3"
	@echo ""
	@echo "  Monitoring:"
	@echo "    - CloudWatch Logs + Metrics     ~$12"
	@echo ""
	@echo "  $(GREEN)Total estim√©: ~$450/mois$(NC)"
	@echo ""

# ============================================================
# Workflows Complets
# ============================================================

deploy: backend init plan apply output-json ## D√©ploiement complet de l'infrastructure
	@echo ""
	@echo "$(GREEN)=========================================$(NC)"
	@echo "$(GREEN)‚úÖ D√©ploiement complet termin√© !$(NC)"
	@echo "$(GREEN)=========================================$(NC)"
	@echo ""

check: validate fmt ## V√©rifier la configuration et formater
	@echo "$(GREEN)‚úÖ Checks termin√©s$(NC)"

.DEFAULT_GOAL := help
